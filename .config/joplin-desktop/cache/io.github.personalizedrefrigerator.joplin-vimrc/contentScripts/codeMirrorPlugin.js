(()=>{"use strict";var e={};({424:function(e,n){var o=this&&this.__awaiter||function(e,n,o,r){return new(o||(o=Promise))((function(s,t){function i(e){try{c(r.next(e))}catch(e){t(e)}}function a(e){try{c(r.throw(e))}catch(e){t(e)}}function c(e){var n;e.done?s(e.value):(n=e.value,n instanceof o?n:new o((function(e){e(n)}))).then(i,a)}c((r=r.apply(e,n||[])).next())}))};Object.defineProperty(n,"__esModule",{value:!0}),n.default=e=>({plugin:n=>{const r=o=>{try{((e,n)=>{var o;const r=["insert","visual","normal"];for(const e of r)n.mapclear(e);const s=e.split("\n");let t=0;for(const e of s){t++;let r=e;if(r=r.replace(/^\s+/,""),r=r.replace(/^\s*["][^"]*$/,""),r=r.replace(/[\r]$/,""),""===r)continue;const s=/^\s*(i|n|v|)(map|noremap)\s+(\S+)\s+(.+)$/,i=/^\s*(i|n|v|)(unmap)\s+(.*)$/,a=null!==(o=s.exec(r))&&void 0!==o?o:i.exec(r);if(!a)throw console.error("line: %s. Run window.testVimrcCommand(line) to try matching a command.",r),window.testVimrcCommand=e=>{var n;return null!==(n=s.exec(e))&&void 0!==n?n:i.exec(e)},new Error(`Unknown command on line ${t}: ${e}`);const c=a[1],l=a[2],u=a[3],m=a[4],d=[];if(""===c)d.push("insert","normal","visual");else if("i"===c)d.push("insert");else if("v"===c)d.push("visual");else{if("n"!==c)throw new Error(`Invalid mode on line ${t}: ${c}`);d.push("normal")}for(const e of d){switch(l){case"map":n.map(u,m,e);break;case"unmap":n.unmap(u,e);break;case"noremap":n.noremap(u,m,e)}console.log("vimrc plugin: Processing: cmd(%s), from(%s), to(%s), mode(%s). %s: %s",l,u,m,e,"from line",r)}}})(o,n.Vim)}catch(n){console.error(n),e.postMessage({kind:"log-error",errorMessage:n})}};var s,t;o(void 0,void 0,void 0,(function*(){const n=yield e.postMessage({kind:"get-vimrc"});r(n)})),s=e=>{if("set-vimrc"!==e.kind)throw new Error("Invalid message!");r(e.content)},t=e.postMessage,o(void 0,void 0,void 0,(function*(){for(;;){const e=yield t({kind:"set-callback"});if("string"==typeof e)throw new Error(`Invalid callback result: ${e}`);s(e)}}))}})}})[424](0,e),exports.default=e.default})();